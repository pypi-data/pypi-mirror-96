{"version":3,"sources":["listItemsCollection.es6.js"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;AAYA,QAAQ,MAAR,CAAe,SAAf,GAA2B,SAAS,UAAT,CAAoB,MAApB,CAA2B;AAClD;;;;;;;;;;AAUA,YAXkD,sBAWvC,MAXuC,EAW/B,OAX+B,EAWtB;AACxB,SAAK,OAAL,GAAe,OAAf;AACH,GAbiD;;;AAelD;;;;;;;;;;;AAWA,OA1BkD,iBA0B5C,OA1B4C,EA0BnC;AACX,SAAK,OAAL,CAAa,UAAb;AACA,aAAS,UAAT,CAAoB,SAApB,CAA8B,KAA9B,CAAoC,IAApC,CAAyC,IAAzC,EAA+C,OAA/C;AACH;AA7BiD,CAA3B,CAA3B","file":"listItemsCollection.js","sourcesContent":["/**\n * Base class for a collection of ListItems.\n *\n * This operations just like a standard Backbone.Collection, with two\n * additions:\n *\n * 1) It stored the provided options, for later usage, preventing subclasses\n *    from having to provide their own initialize function.\n *\n * 2) It emits a \"fetching\" event when calling fetch(), allowing views to\n *    provide a visual indication when items are being fetched or rendered.\n */\nDjblets.Config.ListItems = Backbone.Collection.extend({\n    /**\n     * Initialize the collection.\n     *\n     * Args:\n     *     models (array):\n     *         The models to add to the collection.\n     *\n     *     options (object):\n     *         Options for the collection.\n     */\n    initialize(models, options) {\n        this.options = options;\n    },\n\n    /**\n     * Fetch the contents of the collection.\n     *\n     * This will emit the ``fetching`` event, and then call\n     * Backbone.Collection's fetch().\n     *\n     * Args:\n     *     options (object):\n     *         Options to pass to\n     *         :js:meth:`Backbone.Collection.prototype.fetch`.\n     */\n    fetch(options) {\n        this.trigger('fetching');\n        Backbone.Collection.prototype.fetch.call(this, options);\n    },\n});\n"]}