# vim: set ft=ruby ts=4 sw=4 sts=-1 noet:
#
# This configuration file is licensed under the CC0 license.
# Do whatever you want with it.
#
# This is autokernel's hardening module.
# It is designed to harden many aspects of the kernel based on choices
# taken from several projects:
#
# - [KSSP](https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings)
# - [CLIP OS](https://docs.clip-os.org/clipos/kernel.html#configuration)
# - [kconfig-hardened-check](https://github.com/a13xp0p0v/kconfig-hardened-check)

module hardening {
	# You may want to modify these variables:
	# Before including this module:
	# - MODULES <y/n>
	# - DEVMEM <y/n>
	# After including this module:
	# - MODULE_SIG_KEY "path/to/sigining_key.pem"

	# The hardening module requires at least kernel version 4.0.
	# Everything after 4.0 is manually guarded.
	assert $kernel_version >= 4.0: 'hardening module is designed for kernel versions >= 4.0';

	# This unlocks extra configuration options we need
	set EXPERT y;

	# Preventing loading of modules prevents root from altering kernel memory,
	# if the user hasn't already set this
	try set MODULES n;
	# Prefer to not allow direct physical memory access, if the user hasn't already set this.
	# The /dev/mem device should not be required by any user application nowadays.
	try set DEVMEM n;

	if MODULES {
		# Enforce strict memory mappings permissions for loadable kernel modules.
		if $kernel_version >= 4.11 {
			set STRICT_MODULE_RWX y;
		} else {
			set DEBUG_SET_MODULE_RONX y;
		}

		# But if MODULES is enabled, at least they should be signed with a per-build key.
		set MODULE_SIG y;
		set MODULE_SIG_ALL y;
		# Set signature to SHA512
		set MODULE_SIG_SHA512 y;
		# Require signed modules
		set MODULE_SIG_FORCE y;
	}

	# Dangerous; enabling this allows direct physical memory writing.
	set ACPI_CUSTOM_METHOD n;

	# Dangerous; enabling this disables brk ASLR.
	set COMPAT_BRK n;

	# Dangerous; enabling this allows direct kernel memory writing.
	set DEVKMEM n;

	# Dangerous; exposes kernel text image layout.
	set PROC_KCORE n;

	# Dangerous; enabling this disables VDSO ASLR.
	set COMPAT_VDSO n;

	# Dangerous; Disable the kexec() system call to prevent an already-root
	# attacker from rebooting on an untrusted kernel.
	set KEXEC n;
	set KEXEC_FILE n;

	# Dangerous; enabling this allows replacement of running kernel.
	set HIBERNATION n;

	# Prior to v4.1, assists heap memory attacks
	set INET_DIAG n if $kernel_version < 4.1;

	# We do not want our kernel to support miscellaneous binary classes.
	# ELF binaries and interpreted scripts starting with a shebang are enough
	# Also easily confused by misconfigured userspace, keep off.
	set BINFMT_MISC n;
	# Also disable a.out/ECOFF format. (This is unrelated to a.out files
	# generated by gcc and alike, which are ELF files)
	set BINFMT_AOUT n;

	# Use the modern PTY interface (devpts) only.
	set LEGACY_PTYS n;

	# The userfaultfd() system call adds attack surface and can make heap sprays easier.
	# Note that the vm.unprivileged_userfaultfd sysctl can also be used to restrict the
	# use of this system call to privileged users.
	set USERFAULTFD n if $kernel_version >= 4.3;
	# Disable the uselib system call, which is not needed on systems with a modern libc
	set USELIB n;

	# The /dev/port device should not be used anymore by userspace,
	# and it could increase the kernel attack surface.
	set DEVPORT n;

	# Enabling this feature can make cache side-channel attacks such
	# as FLUSH+RELOAD much easier to carry out.
	set KSM n;

	# Symbols are only useful for debug and attack purposes.
	set KALLSYMS n;

	# User namespaces can be useful for some use cases but even more
	# to an attacker. Optional because required by systemd.
	#set USER_NS n;

	# Do not export ZSMALLOC statistics
	set ZSMALLOC_STAT n;

	# Do not track page owners.
	set PAGE_OWNER n;

	# Disable exporting crashed kernel images through /proc/vmcore
	set PROC_VMCORE n;

	# Disable debug_fs if possible
	try set DEBUG_FS n;

	# Disable kprobes (allow callbacks on any kernel function)
	set KPROBES n;

	# Disable kernel live-patching
	set LIVEPATCH n;

	# Do not automatically load any line discipline that is in a kernel module
	# when an unprivileged user asks for it.
	set LDISC_AUTOLOAD n if $kernel_version >= 5.1;

	# Disable exporting pagetable layout to prevent information leak.
	if $kernel_version >= 5.6 {
		set PTDUMP_DEBUGFS n;
	} else {
		set X86_PTDUMP n;
	}

	# Prevent potential further exploitation of a bug by immediately panicking the kernel.
	set PANIC_ON_OOPS y;
	set PANIC_TIMEOUT -1;

	# Report BUG() conditions and kill the offending process.
	set BUG y;

	if $kernel_version >= 4.19 {
		# Do not credit entropy generated by the CPU manufacturer’s HWRNG
		# nor provided by the bootloader, and included in Linux’s entropy pool.
		# Fast and robust initialization of Linux’s CSPRNG is instead achieved
		# thanks to the TPM’s HWRNG (see documentation of HW_RANDOM_TPM and the
		# rng_core.default_quality command line parameter).
		set RANDOM_TRUST_CPU n;
		set RANDOM_TRUST_BOOTLOADER n;
	}

	# Enable hardware random
	set HW_RANDOM y;
	set HW_RANDOM_INTEL y;
	set HW_RANDOM_AMD y;

	# Enable Expose the TPM’s Random Number Generator (RNG) as a Hardware RNG (HWRNG) and
	# expose the TPM’s Random Number Generator (RNG) as a Hardware RNG (HWRNG)
	# device, allowing the kernel to collect randomness from it. See documentation
	# of RANDOM_TRUST_CPU and the rng_core.default_quality command line parameter
	# for supplementary information.
	set TCG_TPM;
	set HW_RANDOM_TPM y;
	# Increase trust in the TPM’s HWRNG to robustly and fastly initialize Linux’s CSPRNG
	# by crediting half of the entropy it provides.
	add_cmdline "rng_core.default_quality=512";

	# Enable the auditing infrastructure.
	set AUDIT y;

	# Make sure kernel page tables have safe permissions.
	set DEBUG_RODATA y if $kernel_version < 4.11;
	# This is useful even in a production kernel to enable further configuration options
	# that have security benefits.
	set DEBUG_KERNEL y;
	# Enable sanity checks in virtual to page code.
	set DEBUG_VIRTUAL y;
	# Ensure kernel page tables have strict permissions.
	set STRICT_KERNEL_RWX y if $kernel_version >= 4.11;
	# Check and report any dangerous memory mapping permissions, i.e., both writable and
	# executable kernel pages.
	set DEBUG_WX y if $kernel_version >= 4.4;

	# Use strong stack protector for best stack canary coverage.
	if $kernel_version >= 4.18 {
		set STACKPROTECTOR y;
		set STACKPROTECTOR_STRONG y;
	} else {
		set CC_STACKPROTECTOR_STRONG y;
	}

	# If you must have DEVMEM, at least enable STRICT mode
	if DEVMEM {
		set STRICT_DEVMEM y;
		set IO_STRICT_DEVMEM y if $kernel_version >= 4.5;
	}

	# Provides some protections against SYN flooding.
	set SYN_COOKIES y;

	# Perform additional validation of various commonly targeted structures.
	set DEBUG_CREDENTIALS y;
	set DEBUG_NOTIFIERS y;
	set DEBUG_LIST y;
	set DEBUG_SG y;
	set BUG_ON_DATA_CORRUPTION y if $kernel_version >= 4.10;
	set SCHED_STACK_END_CHECK y;

	# Provide userspace with seccomp BPF API for syscall attack surface reduction.
	set SECCOMP y;

	# Enable us to choose different security modules.
	set SECURITY y;
	# Enable SELinux for hosts that intend to leverage it in their security model.
	set SECURITY_SELINUX y;
	# We do not need SELinux to be disableable by a boot parameter.
	set SECURITY_SELINUX_BOOTPARAM n;
	# We do not want SELinux to be disabled. In addition, keeping this option off makes
	# LSM structures such as security hooks read-only.
	set SECURITY_SELINUX_DISABLE n;
	# For now, but should eventually be set to n.
	try set SECURITY_SELINUX_DEVELOP y;

	# Enables ptrace scope restrictions.
	set SECURITY_YAMA y;

	# Perform usercopy bounds checking. (And disable fallback to gain full whitelist enforcement.)
	if $kernel_version >= 4.8 {
		# Harden data copies between kernel and user spaces, preventing classes
		# of heap overflow exploits and information leaks.
		set HARDENED_USERCOPY y;
		set HARDENED_USERCOPY_PAGESPAN n;
		# Use strict whitelisting mode, i.e., do not WARN().
		set HARDENED_USERCOPY_FALLBACK n if $kernel_version >= 4.16;
	}

	# Merging SLAB pages can make heap exploitation easier
	set SLAB_MERGE_DEFAULT n if $kernel_version >= 4.13;
	# Randomize allocator freelists.
	set SLAB_FREELIST_RANDOM y if $kernel_version >= 4.7;
	# Harden slab metadata.
	set SLAB_FREELIST_HARDENED y if $kernel_version >= 4.14;

	# Randomize high-order page allocation freelist.
	# Page allocator randomization is primarily a performance improvement for direct-mapped
	# memory-side-cache utilization, but it does reduce the predictability of page allocations
	# and thus complements SLAB_FREELIST_RANDOM. The page_alloc.shuffle=1 parameter needs to
	# be added to the kernel command line.
	if $kernel_version >= 5.2 {
		set SHUFFLE_PAGE_ALLOCATOR y;
		add_cmdline "page_alloc.shuffle=1";
	}

	if $kernel_version >= 5.3 {
		# Wipe slab and page allocations
		# This replaces "slub_debug=P" and "page_poison=1" and can control all types
		# of memory allocation and wiping now. The init_on_free is only needed if there
		# is concern about minimizing stale data lifetime.
		set INIT_ON_ALLOC_DEFAULT_ON y;
		set INIT_ON_FREE_DEFAULT_ON y;
	} else {
		if $kernel_version < 5.3 {
			# Allow and enable allocator validation checking.
			set SLUB_DEBUG y;
			add_cmdline "slub_debug=P";
		}

		if $kernel_version >= 4.6 {
			# Wipe higher-level memory allocations when they are freed (needs "page_poison=1").
			set PAGE_POISONING y;
			# Enable buddy allocator free poisoning.
			add_cmdline "page_poison=1";
			# If you can't afford even more performance penalty, set PAGE_POISONING_NO_SANITY=y
			# This only works if HIBERNATION is disabled, as it selects PAGE_POISONING_NO_SANITY.
			set PAGE_POISONING_NO_SANITY n if not HIBERNATION;
			set PAGE_POISONING_ZERO y;
		}
	}

	# Initialize all stack variables on function entry, with
	if $kernel_version >= 5.9 {
		set INIT_STACK_ALL y if CC_HAS_AUTO_VAR_INIT_PATTERN;
	} else if $kernel_version >= 5.2 {
		set INIT_STACK_ALL y if CC_HAS_AUTO_VAR_INIT;
	} else if $kernel_version >= 5.2 and HAVE_GCC_PLUGINS {
		# Force all structures to be initialized before they are passed to other functions.
		# When building with GCC:
		set GCC_PLUGIN_STRUCTLEAK_BYREF_ALL y;
	}

	# Virtually-mapped stacks benefit from guard pages,
	# thus making kernel stack overflows harder to exploit.
	set VMAP_STACK y if $kernel_version >= 4.9;

	# Perform extensive checks on reference counting. (Unconditionally enabled since 5.5)
	set REFCOUNT_FULL y if $kernel_version >= 4.13 and $kernel_version < 5.5;

	# Check for memory copies that might overflow a structure in str*() and
	# mem*() functions both at build-time and run-time.
	set FORTIFY_SOURCE y if $kernel_version >= 4.13;

	if $kernel_version >= 4.8 and HAVE_GCC_PLUGINS {
		# Gather additional entropy at boot time for systems that may not have
		# appropriate entropy sources.
		set GCC_PLUGIN_LATENT_ENTROPY y if $kernel_version >= 4.9;

		# Wipe stack contents on syscall exit (reduces stale data lifetime in stack)
		if $kernel_version >= 5.2 {
			set GCC_PLUGIN_STACKLEAK y;
			set STACKLEAK_METRICS n;
			set STACKLEAK_RUNTIME_DISABLE n;
		}

		# Randomize the layout of system structures. This may have dramatic performance
		# impact, so use with caution or also use GCC_PLUGIN_RANDSTRUCT_PERFORMANCE y;
		if $kernel_version >= 4.13 {
			set GCC_PLUGIN_RANDSTRUCT y;
			set GCC_PLUGIN_RANDSTRUCT_PERFORMANCE n;
		}
	}

	# Needed to benefit from microcode updates and thus security fixes
	# (e.g., additional Intel pseudo-MSRs to be used by the kernel as a
	# mitigation for various speculative execution vulnerabilities).
	set MICROCODE y;
	# Retpolines are needed to protect against Spectre v2.
	set RETPOLINE y if $kernel_version >= 4.15;
	# Always enable spectre_v2 mitigation, even on CPUs that report they are
	# not affected. This implies spectre_v2_user=on, which enables the mitigation
	# against user space to user space task attacks (namely IBPB and STIBP when
	# available and relevant).
	add_cmdline "spectre_v2=on";
	# Always enable spectre_v4 mitigation
	add_cmdline "spec_store_bypass_disable=seccomp";

	# Mitigations for the Microarchitectural Data Sampling (MDS) vulnerability
	# on intel processors, and optionally allow disabling SMT (Simultaneous multithreading)
	# to do so.
	add_cmdline "mds=full";
	# If you want to disable hyperthreading, use this line instead.
	#add_cmdline "mds=full,nosmt";

	# The IOMMU allows for protecting the system’s main memory from arbitrary
	# accesses from devices (e.g., DMA attacks). Note that this is related to
	# hardware features.
	set IOMMU_SUPPORT y;
	set INTEL_IOMMU y;
	set INTEL_IOMMU_SVM y if $kernel_version >= 4.4;
	set INTEL_IOMMU_DEFAULT_ON y;
	set AMD_IOMMU y;
	set AMD_IOMMU_V2 y;
	# Always enable iommu
	add_cmdline "iommu=force";

	# Prevent unprivileged users from gathering information from the kernel log
	# buffer via dmesg(8). Note that this still can be overridden through the
	# kernel.dmesg_restrict sysctl.
	set SECURITY_DMESG_RESTRICT y;
	if $kernel_version >= 4.11 {
		# This makes the kernel route all usermode helper calls to a single binary
		# that cannot have its name changed. Without this, the kernel can be tricked
		# into calling an attacker-controlled binary (e.g. to bypass SMAP, cf.
		# exploitation of CVE-2016-8655).
		set STATIC_USERMODEHELPER y;
		# Currently, we have no need for usermode helpers therefore we simply disable them.
		# If you need them, this path will need to be set to a custom trusted binary in charge
		# of filtering and choosing what real helpers should then be called.
		try set STATIC_USERMODEHELPER_PATH "";
	}

	# In order to work properly, this mitigation requires userspace support
	# that is not commonly configured. You can enable this yourself if you want
	# provide the support on your system.
	try set RESET_ATTACK_MITIGATION n if $kernel_version >= 4.14;
	# This restricts loading modules from one file system only. Must be enabled via cmdline
	# or SECURITY_LOADPIN_ENFORCE=y, which could be used if there is no initramfs.
	set SECURITY_LOADPIN y if $kernel_version >= 4.7;

	if $kernel_version >= 5.4 {
		# Basically, the lockdown LSM tries to strengthen the boundary between
		# the superuser and the kernel.  The integrity mode thus restricts access
		# to features that would allow userland to modify the running kernel, and
		# the confidentiality mode extends these restrictions to features that would
		# allow userland to extract confidential information held inside the kernel.
		set SECURITY_LOCKDOWN_LSM y;
		set SECURITY_LOCKDOWN_LSM_EARLY y;
		set LOCK_DOWN_KERNEL_FORCE_CONFIDENTIALITY y;
	}

	# Use maximum number of randomized bits for the mmap base address on x86_64.
	set ARCH_MMAP_RND_BITS "32" if $kernel_version >= 4.5;

	# First legacy-lsm to initialize: Default to SELinux.
	# This is overwritten by LSM, if set.
	set DEFAULT_SECURITY_SELINUX y;
	# The list of security modules to enable, in load order.
	set LSM "lockdown,yama,loadpin,selinux" if $kernel_version >= 5.1;

	if X86 {
		# Disallow allocating the first 64k of memory. This should in particular
		# be non-zero to prevent the exploitation of kernel NULL pointer bugs.
		set DEFAULT_MMAP_MIN_ADDR 65536;

		if $kernel_version >= 4.15 {
			# Enable Kernel Page Table Isolation to remove an entire class of
			# cache timing side-channels.
			set PAGE_TABLE_ISOLATION y;
			# This force-enables KPTI even on CPUs claiming to be safe from Meltdown.
			add_cmdline "pti=on";
		}
		# Don't allow for 16-bit program emulation and associated LDT tricks.
		set MODIFY_LDT_SYSCALL n if $kernel_version >= 4.3;

		# Enable the RDRAND instruction to benefit from a secure hardware RNG if
		# supported. See also RANDOM_TRUST_CPU.
		set ARCH_RANDOM y;
		# Randomize position of kernel (requires UEFI RNG or bootloader support
		# for /chosen/kaslr-seed DT property).
		set RANDOMIZE_BASE y;

		# Machine Check Exceptions can report suspicious hardware errors, some of
		# which may for instance, on systems with ECC memory, reveal an ongoing
		# Rowhammer attack.
		set X86_MCE y;
		set X86_MCE_INTEL y;
		set X86_MCE_AMD y;
		# Make the kernel panic on uncorrected Machine Check Errors.
		# This could prevent an ongoing Rowhammer attack.
		add_cmdline "mce=0";

		# Disable TSX to mitigate the TSX Asynchronous Abort (TAA) Intel CPU
		# vulnerability. Same as commandline tsx=off.
		set X86_INTEL_TSX_MODE_OFF y;

		# Disable /dev/cpu/*/{msr,cpuid} which would only present userspace
		# with more attack surface.
		set X86_MSR n;
		set X86_CPUID n;

		# Page Attribute Tables are the modern equivalents of MTRRs
		# (Memory Type Range Registers) which can make speculative execution
		# bugs a bit harder to exploit.
		set X86_PAT y;

		# Enable Supervisor Mode Access Prevention to prevent
		# ret2usr exploitation techniques.
		set X86_SMAP y;
		# Enable User Mode Instruction Prevention to prevent some instructions
		# that unnecessarily expose information about the hardware state from
		# being executed in user mode.
		if $kernel_version >= 5.5 {
			set X86_UMIP y;
		} else if $kernel_version >= 4.15 {
			set X86_INTEL_UMIP y;
		}
	}

	if X86_64 {
		set RANDOMIZE_MEMORY y if $kernel_version >= 4.8;
		# The vsyscall table is not required anymore by libc and is a fixed-position
		# potential source of ROP gadgets.
		set LEGACY_VSYSCALL_NONE y if $kernel_version >= 4.4;
		set X86_VSYSCALL_EMULATION n;
		# Remove additional attack surface, unless you really need them.
		try set IA32_EMULATION n;
		# Disable native x32 ABI
		set X86_X32 n;
	} else if X86 {
		# On 32-bit kernels, require PAE for NX bit support.
		set M486 n;
		set HIGHMEM4G n;
		set HIGHMEM64G y;
		set X86_PAE y;
	} else if $arch == "arm64" {
		# Disallow allocating the first 32k of memory (cannot be 64k due to ARM loader).
		set DEFAULT_MMAP_MIN_ADDR 32768;
		# Make sure PAN emulation is enabled.
		set ARM64_SW_TTBR0_PAN y if $kernel_version >= 4.10;
		# Enable Kernel Page Table Isolation to remove an entire class of cache timing side-channels.
		set UNMAP_KERNEL_AT_EL0 y if $kernel_version >= 4.16;
	} else if $arch == "arm" {
		# Disallow allocating the first 32k of memory (cannot be 64k due to ARM loader).
		set DEFAULT_MMAP_MIN_ADDR 32768;
		# For maximal userspace memory area (and maximum ASLR).
		set VMSPLIT_3G y;
		# If building an old out-of-tree Qualcomm kernel, this is similar to STRICT_KERNEL_RWX.
		set STRICT_MEMORY_RWX y;
		# Make sure PXN/PAN emulation is enabled.
		set CPU_SW_DOMAIN_PAN y if $kernel_version >= 4.3;
		# Dangerous; old interfaces and needless additional attack surface.
		set OABI_COMPAT n;
	}
}
