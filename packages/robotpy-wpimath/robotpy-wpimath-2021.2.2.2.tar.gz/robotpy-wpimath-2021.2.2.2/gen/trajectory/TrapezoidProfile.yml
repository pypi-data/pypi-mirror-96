---

classes:
  TrapezoidProfile:
    shared_ptr: false
    force_type_casters:
    - units::second_t
    - units::radians_per_second
    typealias:
    - Distance_t = units::unit_t<Distance>
    - Velocity = units::compound_unit<Distance, units::inverse<units::seconds>>
    - Velocity_t = units::unit_t<Velocity>
    - Acceleration = units::compound_unit<Velocity, units::inverse<units::seconds>>
    - Acceleration_t = units::unit_t<Acceleration>
    - State = typename frc::TrapezoidProfile<Distance>::State
    template_params:
    - Distance
    doc: |
      A trapezoid-shaped velocity profile.

      While this class can be used for a profiled movement from start to finish,
      the intended usage is to filter a reference's dynamics based on trapezoidal
      velocity constraints. To compute the reference obeying this constraint, do
      the following.

      Initialization::

        constraints = TrapezoidProfile.Constraints(kMaxV, kMaxA)
        previousProfiledReference = initialReference

      Run on update::

        profile = TrapezoidProfile(constraints, unprofiledReference, previousProfiledReference)
        previousProfiledReference = profile.calculate(timeSincePreviousUpdate)

      where ``unprofiledReference`` is free to change between calls. Note that
      when the unprofiled reference is within the constraints,
      :meth:`calculate` returns the unprofiled reference unchanged.

      Otherwise, a timer can be started to provide monotonic values for
      ``calculate()`` and to determine when the profile has completed via
      :meth:`isFinished`.
    methods:
      TrapezoidProfile:
        param_override:
          constraints:
            x_type: typename TrapezoidProfile<Distance>::Constraints
          goal:
            x_type: typename TrapezoidProfile<Distance>::State
          initial:
            x_type: typename TrapezoidProfile<Distance>::State
      Calculate:
      TimeLeftUntil:
      TotalTime:
      IsFinished:
    template_inline_code: |
      cls_State
        .def(
          py::init<Distance_t, Velocity_t>(),
          py::arg("position") = 0,
          py::arg("velocity") = 0
        )
        .def_readwrite("position", &frc::TrapezoidProfile<Distance>::State::position)
        .def_readwrite("velocity", &frc::TrapezoidProfile<Distance>::State::velocity)
        .def("__repr__", [=](const State &self) {
          return std::string(clsName) + ".State("
            "position=" + std::to_string(self.position()) + ", "
            "velocity=" + std::to_string(self.velocity()) + ")";
        });
  TrapezoidProfile::Constraints:
    shared_ptr: false
    methods:
      Constraints:
        overloads:
          "":
            ignore: true
          units::unit_t<Velocity>, units::unit_t<Acceleration>:
            param_override:
              maxVelocity_:
                name: maxVelocity
                default: 0
              maxAcceleration_:
                name: maxAcceleration
                default: 0
  TrapezoidProfile::State:
    force_no_default_constructor: true
    shared_ptr: false
    methods:
      operator==:
        cpp_code: .def(py::self == State()
      operator!=:
        cpp_code: .def(py::self != State()

templates:
  TrapezoidProfile:
    qualname: frc::TrapezoidProfile
    params:
      - units::dimensionless::scalar

  # needed for HolonomicDriveController
  TrapezoidProfileRadians:
    qualname: frc::TrapezoidProfile
    params:
      - units::radian
