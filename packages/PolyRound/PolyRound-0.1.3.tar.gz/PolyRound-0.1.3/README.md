Efficient random sampling in convex polytopes relies on a 'rounding' preprocessing step, in which the polytope is rescaled so that the width is as uniform as possible across different dimensions.
PolyRound rounds polytopes on the general form:

<a href="https://www.codecogs.com/eqnedit.php?latex=P&space;:=&space;\{x&space;\in&space;\mathcal{R}^n:&space;A_{eq}x&space;=&space;b_{eq},&space;A_{ineq}x&space;\leq&space;b_{ineq}\}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?P&space;:=&space;\{x&space;\in&space;\mathcal{R}^n:&space;A_{eq}x&space;=&space;b_{eq},&space;A_{ineq}x&space;\leq&space;b_{ineq}\}" title="P := \{x \in \mathcal{R}^n: A_{eq}x = b_{eq}, A_{ineq}x \leq b_{ineq}\}" /></a> with matrices <a href="https://www.codecogs.com/eqnedit.php?latex=A_{eq}&space;\in&space;\mathcal{R}^{m,n}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?A_{eq}&space;\in&space;\mathcal{R}^{m,n}" title="A_{eq} \in \mathcal{R}^{m,n}" /></a> and <a href="https://www.codecogs.com/eqnedit.php?latex=A_{ineq}\in&space;\mathcal{R}^{k,n}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?A_{ineq}\in&space;\mathcal{R}^{k,n}" title="A_{ineq}\in \mathcal{R}^{k,n}" /></a> and vectors <a href="https://www.codecogs.com/eqnedit.php?latex=b_{eq}&space;\in&space;\mathcal{R}^{m}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?b_{eq}&space;\in&space;\mathcal{R}^{m}" title="b_{eq} \in \mathcal{R}^{m}" /></a> and <a href="https://www.codecogs.com/eqnedit.php?latex=b_{ineq}\in&space;\mathcal{R}^{k}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?b_{ineq}\in&space;\mathcal{R}^{k}" title="b_{ineq}\in \mathcal{R}^{k}" /></a>. 

This formulation often arises in Systems Biology as the flux space of a metabolic network.

As output, PolyRound produces a polytope on the form <a href="https://www.codecogs.com/eqnedit.php?latex=P^{r}&space;:=&space;\{v&space;\in&space;\mathcal{R}^l:&space;A^{r}_{ineq}v&space;\leq&space;b^{r}_{ineq}\}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?P^{r}&space;:=&space;\{v&space;\in&space;\mathcal{R}^l:&space;A^{r}_{ineq}v&space;\leq&space;b^{r}_{ineq}\}" title="P^{r} := \{v \in \mathcal{R}^l: A^{r}_{ineq}v \leq b^{r}_{ineq}\}" /></a> where <a href="https://www.codecogs.com/eqnedit.php?latex=l&space;\leq&space;n" target="_blank"><img src="https://latex.codecogs.com/gif.latex?l&space;\leq&space;n" title="l \leq n" /></a> and the zero vector is a stricly interior point. For transforming points back to the original space, it also provides a matrix <a href="https://www.codecogs.com/eqnedit.php?latex=S&space;\in&space;\mathcal{R}^{n,l}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?S&space;\in&space;\mathcal{R}^{n,l}" title="S \in \mathcal{R}^{n,l}" /></a> and a vector <a href="https://www.codecogs.com/eqnedit.php?latex=t&space;\in&space;\mathcal{R}^{n}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?t&space;\in&space;\mathcal{R}^{n}" title="t \in \mathcal{R}^{n}" /></a>, so that <a href="https://www.codecogs.com/eqnedit.php?latex=x&space;=&space;Sv&space;&plus;&space;t" target="_blank"><img src="https://latex.codecogs.com/gif.latex?x&space;=&space;Sv&space;&plus;&space;t" title="x = Sv + t" /></a>.

Currently, PolyRound is supported for python 3.7 and 3.8.

PolyRound no longer depends on a Gurobi installation and uses optlang (https://github.com/opencobra/optlang) to delegate linear programs to GLPK in case Gurobi is not installed. However, PolyRound is more reliable with Gurobi. Free Gurobi licenses for academic use can be obtained at https://www.gurobi.com/. Once the license is installed, the easiest way to get gurobi to work in python is through Anaconda https://www.anaconda.com/. Installation of gurobi in a conda environment is done with "conda install -c gurobi gurobi".

An easy example of how to get started is presented in the jupyter notebook "example_usage".
