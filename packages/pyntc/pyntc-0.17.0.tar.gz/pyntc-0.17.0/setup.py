# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pyntc',
 'pyntc.devices',
 'pyntc.devices.system_features',
 'pyntc.devices.system_features.vlans',
 'pyntc.devices.tables',
 'pyntc.devices.tables.jnpr',
 'pyntc.utils',
 'pyntc.utils.templates']

package_data = \
{'': ['*']}

install_requires = \
['bigsuds>=1.0.6,<2.0.0',
 'f5-sdk>=3.0.21,<4.0.0',
 'junos-eznc>=2.4.1,<3.0.0',
 'netmiko>=3.1,<4.0',
 'paramiko>=2.7,<3.0',
 'pyeapi>=0.8.3,<0.9.0',
 'pynxos>=0.0.5,<0.0.6',
 'requests>=2.23,<3.0',
 'scp>=0.13.2,<0.14.0',
 'textfsm>=1.1,<2.0']

setup_kwargs = {
    'name': 'pyntc',
    'version': '0.17.0',
    'description': 'SDK to simplify common workflows for Network Devices.',
    'long_description': '[![Build Status](https://travis-ci.org/networktocode/pyntc.svg?branch=main)](https://travis-ci.org/networktocode/pyntc)\n[![Coverage Status](https://coveralls.io/repos/github/networktocode/pyntc/badge.svg?branch=main)](https://coveralls.io/github/networktocode/pyntc?branch=main)\n\n# Introduction\n\npyntc is an open source multi-vendor Python library that establishes a common framework for working with different network APIs & device types (including IOS devices)\n\nIt\'s main purpose is to simplify the execution of common tasks including:\n  - Executing commands\n  - Copying files\n  - Upgrading devices\n  - Rebooting devices\n  - Saving / Backing Up Configs\n\n# Supported Platforms\n\n* Cisco AireOS - uses netmiko (SSH)\n* Cisco ASA - uses netmiko (SSH)\n* Cisco IOS platforms - uses netmiko (SSH)\n* Cisco NX-OS - uses pynxos (NX-API)\n* Arista EOS - uses pyeapi (eAPI)\n* Juniper Junos - uses PyEz (NETCONF)\n* F5 Networks - uses f5-sdk (ReST)\n\n# Installing pyntc\n\nOption 1:\n\n```\n"pip install pyntc" or "pip install pyntc --upgrade"\n```\n\nOption 2:\n\n```\ngit clone https://github.com/networktocode/pyntc.git\ncd pyntc\npip install poetry\npoetry install\n```\n\n\n# Getting Started with pyntc\n\nThere are two ways to get started with pyntc.\n\nThe first way is to use the `ntc_device` object. Just pass in all required parameters to the object to initialize your device.  Here we are showing the import, but renaming the object to `NTC`.\n\n```\n>>> from pyntc import ntc_device as NTC\n>>>\n```\n\nLike many libraries, we need to pass in the host/IP and credentials.  Because this is a multi-vendor/API library, we also use the `device_type` parameter to identify which device we are building an instance of.\n\npyntc currently supports four device types:\n* cisco_aireos_ssh\n* cisco_asa_ssh\n* cisco_ios_ssh\n* cisco_nxos_nxapi\n* arista_eos_eapi\n* juniper_junos_netconf\n* f5_tmos_icontrol\n\nThe example below shows how to build a device object when working with a Cisco IOS router.\n\n```\n>>> # CREATE DEVICE OBJECT FOR AN IOS DEVICE\n>>>\n>>> csr1 = NTC(host=\'csr1\', username=\'ntc\', password=\'ntc123\', device_type=\'cisco_ios_ssh\')\n>>>\n```\n\nAnd here is an object for a Cisco Nexus device:\n\n```\n>>> # CREATE DEVICE OBJECT FOR A NEXUS DEVICE\n>>>\n>>> nxs1 = NTC(host=\'nxos-spine1\', username=\'ntc\', password=\'ntc123\', device_type=\'cisco_nxos_nxapi\')\n>>>\n```\n\nThe second way to get started with pyntc is to use the pyntc configuration file.  This was modeled after Arista\'s `.eapi.conf` file.  Our file is called `.ntc.conf`\n\nThis simplifies creating device objects since you no longer need to specify credentials and other device specific parameters when you build the device object.  Instead, they are stored in the conf file.\n\n\n# pyntc Configration File\n\n- filename:  `.ntc.conf`\n- Priority of locating the conf file:\n  - `filename` param in `ntc_device_by_name`\n  - Environment Variable aka `PYNTC_CONF`\n  - Home directory `.ntc.conf`\n- Specify device_type and a name\n- host is not required if the name is the device\'s FQDN\n- Four supported device types: `cisco_nxos_nxapi`, `cisco_ios_ssh`, `arista_eos_eapi`, and `juniper_junos_netconf`\n\nHere is an example `.ntc.conf` file:\n\n```bash\n[cisco_nxos_nxapi:nxos-spine1]\nhost: 31.220.64.117\nusername: ntc\npassword: ntc123\ntransport: http\n\n[cisco_ios_ssh:csr1]\nhost: 176.126.88.94\nusername: ntc\npassword: ntc123\nport: 22\n\n[juniper_junos_netconf:vmx1]\nhost: 176.126.88.99\nusername: ntc\npassword: ntc123\n\n```\n\nWe can now build device objects just by referencing the name of the device from the conf file.\n\n```\n>>> from pyntc import ntc_device_by_name as NTCNAME\n>>>\n>>> csr1 = NTCNAME(\'csr1\')\n>>>\n>>> nxs1 = NTCNAME(\'nxos-spine1\')\n>>>\n>>> vmx1 = NTCNAME(\'vmx1\')\n```\n\n\nOnce the device object is creating using either `ntc_device` or `ntc_device_by_name`, you can start using the built-in device methods in pyntc.\n\nNote: the only method and property not supported on all devices is `install_os`.  It is not supported on Juniper Junos devices.\n\n### Gathering Facts\n\n- Use `facts` device property\n\nOn a Nexus device:\n\n```\n>>> nxs1 = NTCNAME(\'nxos-spine1\')\n>>>\n>>> nxs1.facts\n{\'vendor\': \'cisco\', \'interfaces\': [], u\'hostname\': \'nxos-spine1\', u\'os_version\': \'7.1(0)D1(1) [build 7.2(0)ZD(0.17)]\', u\'serial_number\': \'TM600C2833B\', u\'model\': \'NX-OSv Chassis\', \'vlans\': [\'1\']}\n>>>\n>>> print(json.dumps(nxs1.facts, indent=4))\n{\n    "vendor": "cisco",\n    "interfaces": [],\n    "hostname": "nxos-spine1",\n    "os_version": "7.1(0)D1(1) [build 7.2(0)ZD(0.17)]",\n    "serial_number": "TM600C2833B",\n    "model": "NX-OSv Chassis",\n    "vlans": [\n        "1"\n    ]\n}\n```\n\nOn an IOS device:\n\n```\n>>> csr1 = NTCNAME(\'csr1\')\n>>>\n>>> print(json.dumps(csr1.facts, indent=4))\n{\n    "uptime": 87060,\n    "vendor": "cisco",\n    "uptime_string": "01:00:11:00",\n    "interfaces": [\n        "GigabitEthernet1",\n        "GigabitEthernet2",\n        "GigabitEthernet3",\n        "GigabitEthernet4",\n        "Loopback100"\n    ],\n    "hostname": "csr1",\n    "ios": {\n        "config_register": "0x2102"\n    },\n    "fqdn": "N/A",\n    "os_version": "15.5(1)S1",\n    "serial_number": "",\n    "model": "CSR1000V",\n    "vlans": []\n}\n\n```\n\n### Sending Show Commands\n\n- `show` method\n- Note: API enabled devices return JSON by default\n\n```\n>>> nxs1.show(\'show hostname\')\n{\'hostname\': \'nxos-spine1\'}\n>>>\n```\n\n- Use `raw_text=True` to get unstructured data from the device\n\n```\n>>> nxs1.show(\'show hostname\', raw_text=True)\n\'nxos-spine1 \\n\'\n>>>\n```\n\n### Sending Multiple Commands\n\n- `show_list` method\n\n```\n>>> cmds = [\'show hostname\', \'show run int Eth2/1\']\n\n>>> data = nxs1.show_list(cmds, raw_text=True)\n```\n\n```\n>>> for d in data:\n...   print(d)\n...\nnxos-spine1\n\n!Command: show running-config interface Ethernet2/1\n!Time: Wed Jan  6 18:10:01 2016\nversion 7.1(0)D1(1)\ninterface Ethernet2/1\n  switchport\n  no shutdown\n```\n\n### Config Commands\n\n- Use `config` and `config_list`\n\n```\n>>> csr1.config(\'hostname testname\')\n>>>\n```\n\n```\n>>> csr1.config_list([\'interface Gi3\', \'shutdown\'])\n>>>\n```\n\n### Viewing Running/Startup Configs\n\n- Use `running_config` and `start_up` device properties\n  - Only showing partial config (manually shortened for this slide)\n\n```\n>>> run = csr1.running_config\n>>>\n>>> print(run)\nBuilding configuration...\n\nCurrent configuration : 2062 bytes\n!\n! Last configuration change at 18:26:59 UTC Wed Jan 6 2016 by ntc\n!\nversion 15.5\nservice timestamps debug datetime msec\n\nlldp run\ncdp run\n!\nip scp server enable\n!\ninterface GigabitEthernet1\n ip address 10.0.0.50 255.255.255.0\n cdp enable\n```\n\n### Copying files\n\n- `file_copy` method\n\n```\n>>> devices = [csr1, nxs1]\n>>>\n>>> for device in devices:\n...   device.file_copy(\'newconfig.cfg\')\n...\n>>>\n```\n\n### Save Configs\n\n- `save` method\n\n`copy run start` for Cisco/Arista and `commit` for Juniper\n\n```\n>>> csr1.save()\nTrue\n\n```\n\nYou can also do the equivalent of `copy running-config <filename>` by specifying a filename:\n\n```\n>>> csr1.save(\'mynewconfig.cfg\')\nTrue\n```\n\n### Backup Configs\n\nBackup current running configuration and store it locally\n\n```\n>>> csr1.backup_running_config(\'csr1.cfg\')\n>>>\n```\n\n### Reboot\n\nReboot target device\n\nParameters:\n  - `timer=0` by default\n  - `confirm=False` by default\n\n```\n>>> csr1.reboot(confirm=True)\n>>>\n```\n\n### Installing Operating Systems\n\n```python\n>>> device.install_os(\'nxos.7.0.3.I2.1.bin\')\n>>>\n```\n\nFull workflow example:\n\n```python\n>>> device.file_copy(\'nxos.7.0.3.I2.1.bin\')\n>>> device.install_os(\'nxos.7.0.3.I2.1.bin\')\n>>> device.save()\n>>> device.reboot()          # IF NEEDED, NXOS automatically reboots\n>>>\n```\n\n#### Cisco IOS Install Mode Option\n\nNew in 0.15 there is support for [Install Mode](https://content.cisco.com/chapter.sjs?uri=/searchable/chapter/c/en/us/td/docs/switches/lan/Denali_16-1/ConfigExamples_Technotes/Config_Examples/Misc/qos/m_install_vs_bundle.html.xml) upgrades. To execute this there is an option (defaults to False) to run install mode. **file_copy must be executed before install_os**\n\n```python\ndevice.install_os(\'cat9k_iosxe.16.12.04.SPA.bin\', install_mode=True)\n```\n\nWorkflow Example\n\n```python\n>>> device.file_copy(\'cat9k_iosxe.16.12.04.SPA.bin\')\n>>> device.install_os(\'ncat9k_iosxe.16.12.04.SPA.bin\', install_mode=True)  # Reboots device\n```\n\n## Contributing\n\nThis section describes how to install *pyntc* for development, how to run\ntests, and make sure you are a good contributor.\n\n### Branches\n\n<!-- TODO: Correct/complete documentation. -->\n\n- `main` - Reserved for released code\n- `develop` - Work in progress on the main roadmap\n- `<feature>` - Individual feature branches, should be PR\'d to `develop`.\n\n### Installing dependencies for local development\n\nThis repository uses [poetry](https://python-poetry.org/) for dependency\nmanagement.\n\nFor best results, you should use\n[virtualenv](https://virtualenv.pypa.io/en/latest/) and\n[virtualenvwrapper](https://virtualenvwrapper.readthedocs.io/en/latest/), which\ncan both be installed to your system packages using `pip install virtualenv\nvirtualenvwrapper`.\n\nYou\'ll also need Python 3.6+ as your interpreter. See the *virtualenv*\ndocumentation on choosing the correct Python interpretery binary if your system\nprovides multiple versions.\n\nFollow these steps to set up your local development environment:\n\n```bash\n# Make a new virtualenv named "pyntc" and activate it\n$ mkvirtualenv pyntc\n# Double check your version\n$ python --version\nPython 3.7.7\n# Install poetry\n$ pip install poetry\n# Install project dependencies as well as development dependencies\n$ poetry install\n```\n\nIn addition to *poetry*, you may want to install *tox* which is a test\nenvironment controller and runner.\n\n```bash\n# Make sure you\'re in the "pyntc" virtualenv, skip this step if you already are\n$ workon pyntc\n# Install tox\n$ pip install tox\n```\n\n### Running tests locally\n\nThe easiest way to run tests locally is to directly invoke the\n[unittest](https://docs.python.org/3/library/unittest.html) module directly.\n\nTest modules are located in `./test/unit/` and fixtures in `./test/fixtures/`.\n\n```bash\n# Run all tests locally\n$ python -m unittest discover ./test/unit\n```\n\nIt\'s also possible to run local tests using *tox* if you have it installed.\nThis will create separate virtualenvs for each Python version in the `tox.ini`\nconfiguration, and download all dependencies separately.\n\n```bash\n# Run all tests against multiple Python versions\n$ tox\n```\n',
    'author': 'NTC',
    'author_email': 'info@networktocode.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
