#!/usr/bin/env python
# encoding: utf-8

"""
Tool to create a TVG representation of a Ring Road scenario.
This tool predicts contacts occurring in the Ring Road topology using the SGP4
algorithm for orbital propagation. A scenario file (which can be generated by
the "create_rr_scenario" tool) has to be provided. Besides the count of
satellites, ground stations, and the type of Ring Road network, various
further options can be specified. See the usage output provided by the
"--help" command line parameter for all possible input parameters.
"""

from __future__ import (
    unicode_literals,
    print_function,
    absolute_import,
    division,
)

import sys
import json
import argparse
import random

from tvgutil import contact_plan, tvg
from tvgutil.ring_road.contact_plan import (
    get_rr0_contact_tuples,
    get_isl_contact_tuples,
    get_hot_spot_contact_tuples,
)

_SUPPORTED_RRTYPES = ["0", "i", "p", "ip", "s", "is", "ips"]


def _main(args):
    if args.seed is not None:
        random.seed(args.seed)

    is_rrp = "p" in args.rr
    is_rri = "i" in args.rr
    is_rrs = "s" in args.rr

    scenario = json.load(args.FILE)

    gs_list = scenario["gslist"]
    if args.gs is not None:
        assert args.gs > 0 and args.gs <= len(gs_list)
        gs_list = gs_list[0:args.gs]

    sat_list = scenario["satlist"]
    if args.sats is not None:
        assert args.sats > 0 and args.sats <= len(sat_list)
        sat_list = sat_list[0:args.sats]

    time_offset = scenario["time_offset"]

    print("Creating PCP: {} sat(s), {} gs(s), duration: {} h...".format(
        len(sat_list),
        len(gs_list),
        round(args.duration / 3600, 4),
    ), file=sys.stderr)

    print("Predicting sat-gs contacts...", file=sys.stderr)
    rr0_contacts = get_rr0_contact_tuples(
        sat_list,
        gs_list,
        time_offset,
        args.duration,
        min_elevation=args.minelev,
        precision=args.precision,
        half_period=args.halfperiod,
        step=args.step,
    )
    print("Found {} bidirectional sat-gs contact(s).".format(
        len(rr0_contacts)
    ), file=sys.stderr)
    pcp = contact_plan.contact_tuples_to_pcp(
        rr0_contacts,
        time_offset if args.subtractoffset else 0.0,
        uplink_rate=args.uplinkrate,
        downlink_rate=args.downlinkrate,
        prob_min=(args.pmin if is_rrp else 1.0),
        prob_max=(args.pmax if is_rrp else 1.0),
        symmetric_prob=(not args.asymmetricprobs),
        only_first_node_probabilistic=args.gsprobs,
    )

    if is_rri:
        if args.hotspots:
            for station in gs_list:
                station["hot"] = bool(station["id"] in args.hotspots)
        print("Predicting hot spot contacts...", file=sys.stderr)
        rri_contacts = get_hot_spot_contact_tuples(
            gs_list,
            time_offset,
            args.duration,
        )
        print("Found {} bidirectional hot spot contact(s).".format(
            len(rri_contacts)
        ), file=sys.stderr)
        pcp += contact_plan.contact_tuples_to_pcp(
            rri_contacts,
            time_offset if args.subtractoffset else 0.0,
            uplink_rate=args.hotspotrate,
            downlink_rate=args.hotspotrate,
            prob_min=(args.photmin if is_rrp else 1.0),
            prob_max=(args.photmax if is_rrp else 1.0),
            symmetric_prob=(not args.asymmetricprobs),
            only_first_node_probabilistic=False,
        )

    if is_rrs:
        print("Predicting ISL contacts...", file=sys.stderr)
        rrs_contacts = get_isl_contact_tuples(
            sat_list,
            time_offset,
            args.duration,
            args.islrange,
            precision=args.precision,
            max_duration=args.maxislduration,
            step=args.islstep,
        )
        print("Found {} bidirectional ISL contact(s).".format(
            len(rrs_contacts)
        ), file=sys.stderr)
        pcp += contact_plan.contact_tuples_to_pcp(
            rrs_contacts,
            time_offset if args.subtractoffset else 0.0,
            uplink_rate=args.islrate,
            downlink_rate=args.islrate,
            prob_min=(args.pislmin if is_rrp else 1.0),
            prob_max=(args.pislmax if is_rrp else 1.0),
            symmetric_prob=(not args.asymmetricprobs),
            only_first_node_probabilistic=False,
        )

    # finally, filter by minimum duration of contacts
    pcp = [c for c in pcp if c.end_time - c.start_time >= args.minduration]

    print("Resulting unidirectional PCP has {} entries.".format(
        len(pcp)
    ), file=sys.stderr)
    graph = tvg.from_contact_plan(pcp)
    json.dump(
        tvg.to_serializable(graph),
        args.output,
        indent=(4 if args.indent else None),
    )
    args.output.write("\n")
    args.output.close()
    print("Wrote P-TVG structure with {} vertices and {} edges.".format(
        len(graph.vertices),
        len(graph.edges),
    ), file=sys.stderr)


def _get_argument_parser():
    parser = argparse.ArgumentParser(
        description="Ring Road TVG creation tool")
    parser.add_argument("FILE", nargs="?",
                        type=argparse.FileType("r"), default=sys.stdin,
                        help="the base scenario file")
    parser.add_argument("-r", "--rr", choices=_SUPPORTED_RRTYPES, default="0",
                        help="type of the Ring Road network (default=RR0)")
    parser.add_argument("-g", "--gs", type=int, default=None,
                        help="'taken' gs count (default=all)")
    parser.add_argument("-s", "--sats", type=int, default=None,
                        help="'taken' sat count (default=all)")
    parser.add_argument("-d", "--duration", type=float, default=86400.0,
                        help="simulation duration, in seconds (default=86400)")
    parser.add_argument("-e", "--minelev", type=float, default=10.0,
                        help="minimum elevation, in degrees (default=10.0)")
    parser.add_argument("-U", "--uplinkrate", type=float, default=250e3,
                        help="bit rate for the uplink (default=250 kbit/s)")
    parser.add_argument("-D", "--downlinkrate", type=float, default=250e3,
                        help="bit rate for the uplink (default=250 kbit/s)")
    parser.add_argument("--subtractoffset", action="store_true",
                        help="subtract time offset from result intervals")
    parser.add_argument("--minduration", type=float, default=0.0,
                        help="minimum contact duration, in s (default=0.0)")
    parser.add_argument("--hotspots", type=str, nargs="*", default=[],
                        help="override the hot spots (default=use scenario)")
    parser.add_argument("--hotspotrate", type=float, default=1e9,
                        help="RRi: bit rate for hot spots (default=1 Gbit/s)")
    parser.add_argument("--islrange", type=float, default=0.0,
                        help="RRs: ISL range, in km (default=0.0)")
    parser.add_argument("--islrate", type=float, default=250e3,
                        help="RRs: bit rate for ISLs (default=250 kbit/s)")
    parser.add_argument("--pmin", type=float, default=0.8,
                        help="RRp: minimum prob. for sat-gs (default=0.8)")
    parser.add_argument("--pmax", type=float, default=1.0,
                        help="RRp: maximum prob. for sat-gs (default=1.0)")
    parser.add_argument("--photmin", type=float, default=1.0,
                        help="RRip: minimum prob. for hot spots (default=1.0)")
    parser.add_argument("--photmax", type=float, default=1.0,
                        help="RRip: maximum prob. for hot spots (default=1.0)")
    parser.add_argument("--pislmin", type=float, default=0.8,
                        help="RRsp: minimum prob. for ISLs (default=0.8)")
    parser.add_argument("--pislmax", type=float, default=1.0,
                        help="RRsp: maximum prob. for ISLs (default=1.0)")
    parser.add_argument("--asymmetricprobs", action="store_true",
                        help="RRp: use asymmetric probabilities")
    parser.add_argument("--gsprobs", action="store_true",
                        help="RRp: use per-GS probabilities")
    parser.add_argument("-o", "--output",
                        type=argparse.FileType("w"), default=sys.stdout,
                        help="output JSON file for the TVG")
    parser.add_argument("-i", "--indent", action="store_true",
                        help="specify this if you want pretty JSON")
    parser.add_argument("--step", type=float, default=300.0,
                        help="time step for the simulation (default=300.0)")
    parser.add_argument("--precision", type=float, default=0.1,
                        help="precision for finding maxima (default=0.1)")
    parser.add_argument("--halfperiod", type=float, default=2700.0,
                        help="half contact period for zeros (default=2700.0)")
    parser.add_argument("--maxislduration", type=float, default=600.0,
                        help="RRs: maximum ISL duration (default=600.0)")
    parser.add_argument("--islstep", type=float, default=100.0,
                        help="RRs: ISL approximation step (default=100.0)")
    parser.add_argument("--islbracketstep", type=float, default=50.0,
                        help="RRs: ISL bracket finding step (default=50.0)")
    parser.add_argument("--seed", type=float, default=None,
                        help="random seed, to get deterministic results")
    return parser


if __name__ == "__main__":
    _main(_get_argument_parser().parse_args())
