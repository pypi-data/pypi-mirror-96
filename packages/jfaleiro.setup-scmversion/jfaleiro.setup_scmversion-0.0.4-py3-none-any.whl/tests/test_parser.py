#
#     setup_scmversion - Builds a pythonic version number based on scm tags
#                        and branches.
#
#     Copyright (C) 2019 Jorge M. Faleiro Jr.
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU Affero General Public License as published
#     by the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU Affero General Public License for more details.
#
#     You should have received a copy of the GNU Affero General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


import os

import pytest
from setup_scmversion.parser import (_version_match, _version_type_match,
                                     check_tag, parser_factory, parsers,
                                     show_tagged, tag_version)
from setup_scmversion.scm.git import GitParser


@pytest.fixture
def tmp_version_file(tmp_path):
    return tmp_path / '_version.py'


@pytest.fixture
def version_file_content():
    parser = parser_factory()
    return [
        '', '# automatically generated by setup_scmversion',
            '',
            f'__version__ = "{parser.version()}"',
            f'__version_type__ = "{parser.version_type().name}"'
    ]


def test_parsers():
    assert parsers() == "['git']"


def test_parser_factory():
    parser = parser_factory(scm='git')
    assert parser == parser_factory(scm='git')


def test_parser_factory_default_is_git():
    parser = parser_factory()
    assert isinstance(parser, GitParser)


def test_parser_factory_invalid():
    with pytest.raises(ValueError) as e:
        parser_factory(scm='blah')
    assert e.value.args == ("scm 'blah' invalid (options: ['git'])",)


def test_tag_version():
    assert tag_version() == ('setup_scmversion', '_version.py')


def remove_if_exists(filename):
    return os.remove(filename) if os.path.exists(filename) else None


def test_tag_version_no_packages_detected():
    with pytest.raises(ValueError) as e:
        tag_version(exclude='tests setup_scmversion'.split())
    assert e.value.args == ('no default package detected',)


def test_tag_version_multiple_packages_detected():
    with pytest.raises(ValueError) as e:
        tag_version(exclude=[])
    assert e.value.args == (
        "multiple packages detected: ['setup_scmversion', 'tests']",)


def test_tag_version_when_no_file(tmp_path, tmp_version_file,
                                  version_file_content):
    remove_if_exists(tmp_version_file)
    tag_version(package=tmp_path)
    with open(tmp_version_file) as f:
        assert f.read().splitlines() == version_file_content


def test_tag_version_when_empty_file(tmp_path, tmp_version_file,
                                     version_file_content):
    remove_if_exists(tmp_version_file)
    with open(tmp_version_file, 'w') as f:
        f.write('')
    tag_version(package=tmp_path)
    with open(tmp_version_file) as f:
        assert f.read().splitlines() == version_file_content


def test_tag_version_when_only_version(tmp_path, tmp_version_file,
                                       version_file_content):
    remove_if_exists(tmp_version_file)
    with open(tmp_version_file, 'w') as f:
        f.write('__version__ = "0"')
    tag_version(package=tmp_path)
    with open(tmp_version_file) as f:
        assert f.read().splitlines() == version_file_content


def test_tag_version_when_only_version_type(tmp_path, tmp_version_file,
                                            version_file_content):
    remove_if_exists(tmp_version_file)
    with open(tmp_version_file, 'w') as f:
        f.write('__version_type__ = "0"')
    tag_version(package=tmp_path)
    with open(tmp_version_file) as f:
        assert f.read().splitlines() == version_file_content


def test_tag_version_when_file_exists(tmp_path, tmp_version_file,
                                      version_file_content):
    remove_if_exists(tmp_version_file)
    with open(tmp_version_file, 'w') as f:
        f.write('__version__ = "0"')
        f.write('__version_type__ = "0"')
    tag_version(package=tmp_path)
    with open(tmp_version_file) as f:
        assert f.read().splitlines() == version_file_content


def test_version_match():
    assert _version_match('__version__ = "0.0.4.dev16"') == "0.0.4.dev16"
    assert _version_match('__version__="0.0.4.dev16"') == "0.0.4.dev16"
    assert _version_match("__version__ = '0.0.4.dev16'") == "0.0.4.dev16"
    assert _version_match("__version__='0.0.4.dev16'") == "0.0.4.dev16"
    assert _version_match("__version__=   '0.0.4.dev16'") == "0.0.4.dev16"


def test_version_type_match():
    assert _version_type_match(
        '__version_type__ = "RELEASE_BRANCH"') == "RELEASE_BRANCH"
    assert _version_type_match(
        "__version_type__ = 'RELEASE_BRANCH'") == "RELEASE_BRANCH"


def test_show_tagged(tmp_path, tmp_version_file):
    remove_if_exists(tmp_version_file)
    with open(tmp_version_file, 'w') as f:
        f.write('__version__ = "0.0.4.dev16"\n')
        f.write('__version_type__ = "RELEASE_BRANCH"\n')
    assert show_tagged(package=tmp_path) == ("0.0.4.dev16", "RELEASE_BRANCH")


def test_show_tagged_empty(tmp_path, tmp_version_file):
    remove_if_exists(tmp_version_file)
    with open(tmp_version_file, 'w') as f:
        f.write('\n')
    assert show_tagged(package=tmp_path) == ("", "")


def test_check_tag(tmp_path, tmp_version_file):
    parser = parser_factory(scm='git')
    version, version_type = parser.version(), parser.version_type().name
    remove_if_exists(tmp_version_file)
    with open(tmp_version_file, 'w') as f:
        f.write(f'__version__ = "{version}"\n')
        f.write(f'__version_type__ = "{version_type}"\n')
    check_tag(package=tmp_path) == (version, version_type)
